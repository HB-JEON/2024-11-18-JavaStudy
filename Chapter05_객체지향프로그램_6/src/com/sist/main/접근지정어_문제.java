package com.sist.main;
/*
   	1. 객체와 클래스에 대한 설명으로 틀린 것은 무엇입니까?  3
		1) 클래스는 객체를 생성하기 위한 설계도(청사진)와 같은 것이다.
		   ----- 설계
         	자재 > 변수
         	기술 > 메소드
		2) new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성된다.
		    클래스 객체명=new 생성자()
		    Class className.forName("클래스") > 리플렉션 > 객체 생성
		     > 메소드, 멤버변수, 생성자 > 제어가 가능
		3) 하나의 클래스로 하나의 객체만 생성할 수 있다.
		    new를 사용하면 객체는 언제든 생성 가능
		    설계 (class) 1개 > 여러개 객체 생성
		4) 객체는 클래스의 인스턴스이다.
		                  추상화(요구사항) > 공통된 부분 추출
		    객체(사물,Object) > class ClassName > 컴퓨터에 저장
		    사원/회원           {                  | new Sawon()
		                         String name       인스턴스 > 객체
		                         String 부서...
		                      }
	2. 클래스의 구성 멤버가 아닌 것은 무엇입니까?  4
		1) 필드(field)
		    = 멤버변수 - 초기값 O
		2) 생성자(constructor)
		    멤버변수의 초기화 / 객체 생성 시에 호출 / 시작과 동시에 처리
		     > 윈도우 : 레이아웃 (화면 UI), 자동 로그인, 서버 연동, 오라클 드라이버 설정
		    특징 - 클래스명과 동일 / 리턴형 X / 다른 클래스에서 사용 > public / 오버로딩 > 여러 개 생성 가능
		3) 메소드(method)
		    멤버 변수를 이용한 데이터 관리(기능)
		    다른 클래스와 연동 가능 / 오버로딩
		    리턴형 : 실행 결과값 1개만 사용 가능
		     > 사용자 요청 값 : 여러 개 사용 > 매개변수
		4) 로컬 변수(local variable)
		    메소드, 생성자 안에서 사용 > {} 종료되면 사라지는 변수
		    초기값 X
		    
	3. 필드, 생성자, 메소드에 대한 설명으로 틀린 것은 무엇입니까?  4
		1) 필드는 객체의 데이터를 저장한다.
		    변수(데이터 저장 공간)
		2) 생성자는 객체의 초기화를 담당한다.
		3) 메소드는 객체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다.
		    {
		        실행 코드
		    }
		4) 클래스는 반드시 필드와 메소드를 가져야 한다.
		    사용자 정의 데이터형 - 멤버변수만 존재 / VO, DTO
		    액션 클래스 - 메소드만 존재  / DAO, MODEL
		    일반 클래스 - 변수 + 메소드 = 혼합 존재 
		    
	4. 필드에 대한 설명으로 틀린 것은 무엇입니까?  3
		1) 필드는 메소드에서 사용할 수 있다.
		    멤버 변수는 class 영역과 다른 클래스에서도 사용 가능
		2) 인스턴스 필드 초기화는 생성자에서 할 수 있다.
		    명시적 초기화
		    생성자
		    인스턴스 블록
		     class
		     {
		         int a=10;  / 명시적 초기화
		         A()
		         {
		             a=100; / 생성자
		         }
		         {
		             a=1000; / 인스턴스 블록
		         }
		     }
		    기본 초기값 > 명시적 초기화 > 인스턴스 초기화 블록 > 생성자
		                | 명시적 초기화가 가능한지 확인
		                  구현된 상태(파일 읽기, 데이터베이스, 제어문)
		3) 필드는 반드시 생성자 선언 전에 선언되어야 한다.
		    순서는 상관 X                    현 상태도 가능
		     class A                     class A
		     {                           {
		         필드                         생성자  / 초기화 블록
		         생성자 / 초기화 블록             메소드 
		         메소드                        필드      
		     }                           }                    
		4) 필드는 초기값을 주지 않더라고 기본값으로 자동 초기화된다.
		    멤버변수
		    int=0  long=0L  double=0.0  boolean=false  String=null
		    
	5. 생성자에 대한 설명으로 틀린 것은 무엇입니까?  1
		1) 객체를 생성하려면 생성자 호출이 반드시 필요한 것은 아니다.
		    객체 생성 > new 생성자()
		2) 생성자는 다른 생성자를 호출하기 위해 this()를 사용할 수 있다.
		    this() > 자신의 생성자 호출
		     > 생성자 안에서만 호출 가능
		       생성자 안 첫번째 줄에서 사용
		        class A
		        {
		           A()
		           {
		           }
		           A(int a)
		           {
		              System.out.println("");
		              this(); >> 오류 코딩 / 첫번째 줄에만 코딩 가능
		              System.out.println(""); 
		           }
		        }
		3) 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다.
		    매개 변수가 없는 생성사
		     class A
		     {
		        A(){} > 생성자 존재
		     }
		     class A
		     {
		        A(int a){} > 생성자 존재
		     }
		     class A
		     {
		        A(){} > 자동 첨부
		     }
		4) 외부에서 객체를 생성할 수 없도록 생성자에 private 접근 제한자를 붙일 수 있다.
		                                 ------- 다른 클래스 접근 금지
		    생성자 : default, public, protected, private > public

	6. 메소드에 대한 설명으로 틀린 것은 무엇입니까?  4
		리턴형	매개변수
		 o        o
		 o        o
		 x        o > *** 리턴형 없는 경우 void
		 x        x
		1) 리턴값이 없는 메소드는 리턴 타입을 void로 해야 한다.
		2) 리턴 타입이 있는 메소드는 리턴값을 지정하기 위해 반드시 return문이 있어야 한다.
		3) 매개값의 수를 모를 경우 "..."를 이용해서 매개 변수를 선언할 수 있다.
		    ... > 가변 매개변수
		    웹 사용 빈도 높음
		     > 웹에서 데이터를 받는 경우 (개수가 정확하지 않은 경우)
		4) 메소드의 이름은 중복해서 선언할 수 없다.
		    중복 메소드 정의가 가능 > 오버로딩
		
	7. 메소드 오버로딩에 대한 설명으로 틀린 것은 무엇입니까?  2
		1) 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
		2) 반드시 리턴 타입이 달라야 한다.
		    리턴형은 관계 X
		3) 매개 변수의 타입, 수 순서를 다르게 선언해야 한다.
		4) 매개값의 타입 및 수에 따라 호출될 메소드가 선택된다.
		    맞는 데이터형 > 유사 데이터형
		     void aaa(long a) void aaa(int a) aaa(char c) aaa(double d)
		     
		     Aaa(10.5f) > aaa(double d) 가장 유사한 메소드를 호출

	8. 인스턴스 멤버와 정적 멤버에 대한 설명으로 틀린 것은 무엇입니까?  2
		1) 정적 멤버는 static으로 선언된 필드와 메소드를 말한다.
		2) 인스턴스 필드는 생성자 및 정적 블록에서 초기화될 수 있다.
		    정적 블록에서 초기화 불가능 / static 만 사용 가능
		3) 정적 필드와 정적 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다.
		    클래스명.변수명, 클래스명.메소드
		4) 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다.
		    A a=new A() > a.메소드

	9. final 필드와 상수(static final)에 대한 설명으로 틀린 것은 무엇입니까?
		1) final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.
		2) final 필드와 상수는 생성자에서 초기화될 수 있다.
		3) 상수의 이름은 대문자로 작성하는 것이 관례이다.
		4) 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.

	10. 다음 클래스에서 해당 멤버가 필드, 생성자, 메소드 중 어떤 것인지 빈칸을 채우세요.
		public class Member {
		private String name; // -------------------------------------( 메소드  )  
 
    	public Member(String name) { } // ---------------------------( 생성자  )
    
    	public void setName(String name) { } // ---------------------(  인스턴스 필드  )
		}
		Colored by Color Scripter

 */
public class 접근지정어_문제 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
